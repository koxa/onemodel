import { isClass } from '../utils';
import { DEFAULT_CLIENT_ID_ATTR, DEFAULT_ID_ATTR } from './const/base';
import { Config } from './types/BaseConfig';

export default abstract class BaseConfig {
  static config: Config = {
    idAttr: DEFAULT_ID_ATTR,
    clientIdAttr: DEFAULT_CLIENT_ID_ATTR,
    props: null,
    reactivity: false,
    validators: null,
    converters: null,
  };

  config: Config;

  /**
   * Returns config including dynamic values generated by config functions
   * @returns {{}} New object consisting of static config copy + dynamic config functions
   */
  static getConfig(cfgProp?: string): Config {
    const getCfgVal = (prop) => {
      return typeof this.config[prop] === 'function' && !isClass(this.config[prop])
        ? this.config[prop].apply(this)
        : this.config[prop];
    };
    if (cfgProp) {
      return getCfgVal(cfgProp);
    }
    const out = {};
    for (let prop of Object.getOwnPropertyNames(this.config)) {
      out[prop] = getCfgVal(prop);
    }
    return out as Config;
  }

  static configure(config: Partial<Config>) {
    return Object.assign(this.config, config);
  }

  /**
   * Returns FULL CONFIG (merge of class config and instance config)
   * @returns {any}
   */
  getConfig(): any {
    return this.config || BaseConfig.config;
  }

  /**
   * Sets any custom config properties
   * @param config
   * @returns {*} Returns own config object
   */
  setConfig(config: Config) {
    //todo: only store overriden parts of config and merge on fly, because Model might be reconfigure later
    return this.config
      ? Object.assign(this.config, config)
      : this.__defineConfig({ ...this.getConfig(), ...config });
  }

  __defineConfig(config) {
    Object.defineProperty(this, 'config', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: config, // initial value is assigned
    });
    return this['config'];
  }
}
