import Base from "../Base";
import { isClass, deepEqual } from "../../utils";
import { underscoredIf } from "sequelize/lib/utils";

class BaseModel extends Base {
  static _config = {
    //todo: make _config private ? but how to extend in children ? //todo: make it private with es6 '#' private props
    idAttr: "id", //this.getIdAttr(), // id attr is a Primary Key. It is immutable and can't be modified once set  //todo: maybe use null in BaseModel
    props: null, //this.getProps(),
    reactivity: false, //this.getReactivity(),
    validators: null, //this.getValidators(),
    converters: null //this.getConverters()
  };

  /**
   * Returns config including dynamic values generated by config functions
   * @returns {{}} New object consisting of static _config copy + dynamic config functions
   */
  static getConfig(cfgProp) {
    const getCfgVal = (prop) => {
      return typeof this._config[prop] === "function" && !isClass(this._config[prop])
        ? this._config[prop].apply(this)
        : this._config[prop];
    };
    if (cfgProp) {
      return getCfgVal(cfgProp);
    }
    const out = {};
    for (let prop of Object.getOwnPropertyNames(this._config)) {
      out[prop] = getCfgVal(prop);
    }
    return out;
  }

  static configure(config) {
    this._config = { ...this._config, ...config };
    return this._config;
  }

  static validate(prop, val) {
    const validators = this.getConfig("validators");
    if (validators[prop]) {
      return validators[prop](val);
    } else {
      console.log("validator is not defined for prop: ", prop);
    }
  }

  static convert(prop, val) {
    const converters = this.getConfig("converters");
    if (converters[prop]) {
      return converters[prop](val);
    } else {
      console.log("converter is not defined for prop: ", prop);
    }
  }

  /**
   * Parses Prop Configuration to return just default value
   * //todo: maybe move this to mixin
   * @param propObj
   */
  static parsePropConfig(val) {
    switch (typeof val) {
      case "bigint":
      case "boolean":
      case "undefined":
      case "string":
      case "number":
        return val;
      case "object":
        if (Array.isArray(val)) {
          return null; // no default value. todo: should be null or undefined ?
        } else {
          // it's an object: may have Type[Number, Array, String]. If not Type defined check for fields: options = Array, min/max = Number
          let type = val["type"] ?? (val["options"] ? Array : null) ?? (val["min"] || val["max"] ? Number : null);
          //todo: support validator/converter right here
          switch (type) {
            case Number:
            case Array:
            case String:
              return val["value"];
            default:
              throw new Error("Unknown prop config type" + type);
          }
        }
      case "function":
        console.log(val); //todo
      default:
        throw new Error("Unknown prop config value" + val);
    }
  }

  constructor(
    data,
    options = { skipHooks: false, skipConvert: false, skipValidate: false },
    config = {}
  ) {
    super(...arguments);
    if (config && Object.keys(config).length) {
      // if custom config provided store it in instance
      this.__defineConfig({ ...this.constructor.getConfig(), ...config });
    }
    const fullConfig = this.getConfig();
    fullConfig.props &&
    Object.keys(fullConfig.props).forEach((prop) =>
      this.__defineProperty(prop, this.constructor.parsePropConfig(fullConfig.props[prop]), fullConfig.reactivity)
    );
    //this.__defineModified(false);
    data && this.setAll(data, options); // do not skip hooks unless it's specifically set by user
  }

  /**
   * Returns FULL CONFIG (merge of class config and instance config)
   * @returns {any}
   */
  getConfig() {
    return this._config ? this._config : this.constructor.getConfig();
  }

  /**
   * Sets any custom config properties
   * @param config
   * @returns {*} Returns own config object
   */
  setConfig(config) {
    //todo: only store overriden parts of config and merge on fly, because Model might be reconfigure later
    return this._config
      ? Object.assign(this._config, config)
      : this.__defineConfig({ ...this.constructor.getConfig(), ...config });
  }

  getId() {
    let idAttr = this.constructor.getConfig("idAttr");
    return this[idAttr];
  }

  getClientId() {
    return this[this.constructor.getClientIdAttr()];
  }

  setId(id) {
    return this.set(this.getConfig("idAttr"), id);
  }

  get(prop) {
    return this[prop];
  }

  getAll(...exclude) {
    let out = {};
    for (let prop in this) {
      if (this.hasOwnProperty(prop)) {
        // to avoid prototype props since for...in walks prototype
        if (exclude.indexOf(prop) < 0) {
          out[prop] = this[prop];
        }
      }
    }
    return out;
  }

  __defineConfig(config) {
    Object.defineProperty(this, "_config", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: config // initial value is assigned
    });
    return this["_config"];
  }

  // __defineModified(val) {
  //   Object.defineProperty(this, 'isModified', {
  //     configurable: false,
  //     enumerable: false,
  //     writable: true,
  //     value: val,
  //   });
  //   return this['isModified'];
  // }

  __defineId(val) {
    Object.defineProperty(this, this.constructor.getConfig("idAttr"), {
      configurable: true,
      enumerable: true,
      writable: false, // id is immutable by default
      value: val // initial value is assigned
    });
    return this[this.constructor.getConfig("idAttr")];
  }

  __defineProperty(prop, val, reactivity) {
    const def = {
      configurable: true,
      enumerable: true
    };
    const tmpProps = {
      [prop]: val
    };
    def.get = () => {
      return tmpProps[prop];
    };
    def.set = (val) => {
      const prepared = this.__prepareSet(prop, val);
      if (prepared.doSet) {
        val = prepared.val;
        if (reactivity && this.__hookBeforeSet) {
          val = this.__hookBeforeSet(prop, val);
        }
        // if (typeof tmpProps[prop] !== 'undefined') {
        //   this.isModified = true;
        //   this.__hookUpdate && this.__hookUpdate(prop, val);
        // }
        tmpProps[prop] = val;
        reactivity && this.__hookAfterSet && this.__hookAfterSet(prop, val);
      }
    };
    Object.defineProperty(this, prop, def);
  }

  __isPropExists(prop) {
    return Object.keys(this).includes(prop);
  }

  /**
   * Prepare value to be set on model property
   * Should apply any possible validators/converters and then return value to be set
   * @param prop
   * @param val
   * @param options
   */
  __prepareSet(prop, val, options = { skipValidate: false, skipConvert: false }) {
    const validators = this.constructor.getConfig("validators");
    const converters = this.constructor.getConfig("converters");
    const { skipValidate, skipConvert } = options;
    // const propExists = this.__isPropExists(prop);

    if (!skipValidate && validators && validators[prop]) {
      if (!validators[prop](val)) { //todo: record validation error somehow somewhere
        return { doSet: false, prop, val };
      }
    }

    if (!skipConvert && converters && converters[prop]) {
      val = converters[prop](val);
    }

    let doSet = true;
    if (/*propExists &&*/ deepEqual(this[prop], val)) {
      doSet = false; // skip if value is same
    }
    return { doSet: doSet, prop: prop, val: val };
  }

  set(prop, val, options = { skipHooks: false, skipValidate: false, skipConvert: false }) {
    const config = this.getConfig();
    const { skipHooks, skipValidate, skipConvert } = options;

    if (!this.__isPropExists(prop)) {
      // then define prop
      // should be defined with 'undefined' as default value
      this.__defineProperty(prop, undefined, config.reactivity);
    }

    if (config.reactivity) {
      // todo: whether to fire hooks on undefined
      const oldVal = this[prop];
      this[prop] = val; // property's setter will call preparation function
      return val !== oldVal; // if prop didn't exist before or val modified
    } else {
      const prep = this.__prepareSet(prop, val, { skipValidate, skipConvert });
      if (prep.doSet) {
        val = prep.val;
        if (!skipHooks && this.__hookBeforeSet) {
          // now calling only if value doSet
          val = this.__hookBeforeSet(prop, val);
        }
        if (prop === this.constructor.getConfig("idAttr") && this[prop] === undefined) {
          this.__defineId(val); // will define and set id attr as immutable
        } else {
          this[prop] = val;
        }
        !skipHooks && this.__hookAfterSet && this.__hookAfterSet(prop, this[prop]);
      }
      return prep.doSet;
    }
  }

  /**
   * Sets all properties from a passed object to self
   * Will only set properties defined in default props (if available)
   * Ignores properties with undefined values anyway
   *
   * @param data Object to copy data from
   * @param {Boolean} skipHooks Skip Hooks
   * @return {Object} Array of modified props or {} if nothing was modified
   */
  setAll(data = {}, options = { skipHooks: false, skipValidate: false, skipConvert: false }) {
    const modifiedProps = {};
    const { skipHooks } = options;
    !skipHooks && this.__hookBeforeSetAll && this.__hookBeforeSetAll(data); //todo: should hooks be executed even if values not really set ?
    for (let prop in data) {
      if (this.set(prop, data[prop], options)) {
        modifiedProps[prop] = this[prop]; // record modified props and return them at the end
      }
    }
    // if (this.isModified) {
    //   this.isModified = false;
    // }
    !skipHooks && this.__hookAfterSetAll && this.__hookAfterSetAll(modifiedProps, data);
    return modifiedProps;
  }

  unset(prop, skipHooks = false) {
    let deleted = false;
    !skipHooks && this.__hookBeforeUnset && this.__hookBeforeUnset(prop);
    if (prop in this) {
      delete this[prop];
      deleted = true;
    }
    !skipHooks && this.__hookAfterUnset && this.__hookAfterUnset(deleted, prop);
    return deleted;
  }

  __hookAfterConstruct(data) {
    return this;
  }

  __hookBeforeSet(prop, val) {
    return val;
  }

  __hookAfterSet(prop, val) {
    return this;
  }

  __hookBeforeSetAll(data) {
    return data;
  }

  //todo: maybe fire only if something modified
  __hookAfterSetAll(modifiedProps, data) {
    return this;
  }

  __hookBeforeUnset(prop) {
    return prop;
  }

  //todo: maybe fire only if something was unset
  __hookAfterUnset(deleted, prop) {
    return this;
  }
}

export default BaseModel;
